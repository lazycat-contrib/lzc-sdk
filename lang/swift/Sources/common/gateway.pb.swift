// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/gateway.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Cloud_Lazycat_Apis_Common_TransportType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 通用性最强，但会占用额外的端口并走完整的TCP/IP栈
  case tcp // = 0

  /// 仅限服务与Gateway同一进程内调用，数据直接走内存。性能最好，主要是device api类型使用。第三方服务无法使用此类型，仅限内部使用
  /// 特殊接口调用。
  case inProcess // = 1

  /// 走unix socket, 依旧是跨进程但不走TCP/IP协议栈。性能一般，不要求同一进程，但需要让gateway本身能访问到对应服务的socket文件
  case unixSocket // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .tcp
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tcp
    case 1: self = .inProcess
    case 2: self = .unixSocket
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tcp: return 0
    case .inProcess: return 1
    case .unixSocket: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Common_TransportType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Common_TransportType] = [
    .tcp,
    .inProcess,
    .unixSocket,
  ]
}

#endif  // swift(>=4.2)

public enum Cloud_Lazycat_Apis_Common_ServiceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 服务以grpc native的形式曝露给gateway。调用者拨号时直接使用gateway的地址即可，gateway会自动代理对应service name到正确的
  /// 服务后端。
  case grpc // = 0

  /// 服务以http的形式曝露给gateway。 调用者以https的形式访问gateway的地址下的特定url path来访问对应服务后端。
  /// 服务会统一曝露到 `https://api.$boxdomain/s/$service_name/`
  case http // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .grpc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .grpc
    case 1: self = .http
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .grpc: return 0
    case .http: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Common_ServiceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Common_ServiceType] = [
    .grpc,
    .http,
  ]
}

#endif  // swift(>=4.2)

public struct Cloud_Lazycat_Apis_Common_GatewayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 域名信息
  public var baseDomain: String = String()

  /// 服务端口
  public var port: String = String()

  /// 是否使用TLS
  public var isTls: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Common_ServiceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceType: Cloud_Lazycat_Apis_Common_ServiceType = .grpc

  /// 如果是盒子上的第三方服务，则会强制验证$service_name是否与调用者的$appid匹配
  /// 系统内置的服务以及device apis不会做此检查
  public var serviceName: String = String()

  public var transportType: Cloud_Lazycat_Apis_Common_TransportType = .tcp

  public var serviceAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Common_RegisterReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isOk: Bool = false

  public var errorMessage: String = String()

  /// gateway会对appid以及uid进行合法性检测，并在将request传递到service后端前，
  /// 设置到对应的grpc metadata或http header中，具体的字段名称会通过app_id_key以及user_id_key返回
  public var appidKey: String = String()

  public var uidKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Common_AccessHTTPServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Common_HTTPAccessInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 对应服务的URL
  public var serviceURL: String = String()

  /// 若token_headername不为空，
  /// 则必须设置名称为$token_headername的http header为$token_value
  public var authHeadername: String = String()

  public var authValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Lazycat_Apis_Common_TransportType: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_ServiceType: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_GatewayInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_ServiceInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_RegisterReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_AccessHTTPServiceRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Common_HTTPAccessInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.lazycat.apis.common"

extension Cloud_Lazycat_Apis_Common_TransportType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TCP"),
    1: .same(proto: "InProcess"),
    2: .same(proto: "UnixSocket"),
  ]
}

extension Cloud_Lazycat_Apis_Common_ServiceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRPC"),
    1: .same(proto: "HTTP"),
  ]
}

extension Cloud_Lazycat_Apis_Common_GatewayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatewayInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_domain"),
    2: .same(proto: "port"),
    3: .standard(proto: "is_tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.port) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isTls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDomain, fieldNumber: 1)
    }
    if !self.port.isEmpty {
      try visitor.visitSingularStringField(value: self.port, fieldNumber: 2)
    }
    if self.isTls != false {
      try visitor.visitSingularBoolField(value: self.isTls, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Common_GatewayInfo, rhs: Cloud_Lazycat_Apis_Common_GatewayInfo) -> Bool {
    if lhs.baseDomain != rhs.baseDomain {return false}
    if lhs.port != rhs.port {return false}
    if lhs.isTls != rhs.isTls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Common_ServiceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_type"),
    2: .standard(proto: "service_name"),
    3: .standard(proto: "transport_type"),
    4: .standard(proto: "service_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.serviceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.transportType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serviceType != .grpc {
      try visitor.visitSingularEnumField(value: self.serviceType, fieldNumber: 1)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 2)
    }
    if self.transportType != .tcp {
      try visitor.visitSingularEnumField(value: self.transportType, fieldNumber: 3)
    }
    if !self.serviceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAddr, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Common_ServiceInfo, rhs: Cloud_Lazycat_Apis_Common_ServiceInfo) -> Bool {
    if lhs.serviceType != rhs.serviceType {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.transportType != rhs.transportType {return false}
    if lhs.serviceAddr != rhs.serviceAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Common_RegisterReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_ok"),
    2: .standard(proto: "error_message"),
    3: .standard(proto: "appid_key"),
    4: .standard(proto: "uid_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isOk) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appidKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uidKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isOk != false {
      try visitor.visitSingularBoolField(value: self.isOk, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.appidKey.isEmpty {
      try visitor.visitSingularStringField(value: self.appidKey, fieldNumber: 3)
    }
    if !self.uidKey.isEmpty {
      try visitor.visitSingularStringField(value: self.uidKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Common_RegisterReply, rhs: Cloud_Lazycat_Apis_Common_RegisterReply) -> Bool {
    if lhs.isOk != rhs.isOk {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.appidKey != rhs.appidKey {return false}
    if lhs.uidKey != rhs.uidKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Common_AccessHTTPServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessHTTPServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Common_AccessHTTPServiceRequest, rhs: Cloud_Lazycat_Apis_Common_AccessHTTPServiceRequest) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Common_HTTPAccessInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HTTPAccessInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_url"),
    2: .standard(proto: "auth_headername"),
    3: .standard(proto: "auth_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authHeadername) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceURL, fieldNumber: 1)
    }
    if !self.authHeadername.isEmpty {
      try visitor.visitSingularStringField(value: self.authHeadername, fieldNumber: 2)
    }
    if !self.authValue.isEmpty {
      try visitor.visitSingularStringField(value: self.authValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Common_HTTPAccessInfo, rhs: Cloud_Lazycat_Apis_Common_HTTPAccessInfo) -> Bool {
    if lhs.serviceURL != rhs.serviceURL {return false}
    if lhs.authHeadername != rhs.authHeadername {return false}
    if lhs.authValue != rhs.authValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
