// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sys/portal-server/portal-server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Cloud_Lazycat_Apis_Sys_Role: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case normal // = 0
  case admin // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .admin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .admin: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Sys_Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Sys_Role] = [
    .normal,
    .admin,
  ]
}

#endif  // swift(>=4.2)

public struct Cloud_Lazycat_Apis_Sys_GenUserInvitationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 仅限注册此uid
  public var limitUid: String {
    get {return _limitUid ?? String()}
    set {_limitUid = newValue}
  }
  /// Returns true if `limitUid` has been explicitly set.
  public var hasLimitUid: Bool {return self._limitUid != nil}
  /// Clears the value of `limitUid`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUid() {self._limitUid = nil}

  /// 在此时间前有效
  public var notAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _notAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_notAfter = newValue}
  }
  /// Returns true if `notAfter` has been explicitly set.
  public var hasNotAfter: Bool {return self._notAfter != nil}
  /// Clears the value of `notAfter`. Subsequent reads from it will return its default value.
  public mutating func clearNotAfter() {self._notAfter = nil}

  /// 此邀请最多使用多少次
  public var limitUsageCount: Int32 {
    get {return _limitUsageCount ?? 0}
    set {_limitUsageCount = newValue}
  }
  /// Returns true if `limitUsageCount` has been explicitly set.
  public var hasLimitUsageCount: Bool {return self._limitUsageCount != nil}
  /// Clears the value of `limitUsageCount`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUsageCount() {self._limitUsageCount = nil}

  /// 自动设置role为此字段，默认为NORMAL
  public var limitRole: Cloud_Lazycat_Apis_Sys_Role {
    get {return _limitRole ?? .normal}
    set {_limitRole = newValue}
  }
  /// Returns true if `limitRole` has been explicitly set.
  public var hasLimitRole: Bool {return self._limitRole != nil}
  /// Clears the value of `limitRole`. Subsequent reads from it will return its default value.
  public mutating func clearLimitRole() {self._limitRole = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limitUid: String? = nil
  fileprivate var _notAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitUsageCount: Int32? = nil
  fileprivate var _limitRole: Cloud_Lazycat_Apis_Sys_Role? = nil
}

public struct Cloud_Lazycat_Apis_Sys_UserInvitation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ListUsersReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_PairDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srcID: String = String()

  public var otherIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AllocVEIPRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 简短说明使用原因，方便后续管理
  public var usage: String = String()

  /// 关联的子域名。hserver会自动将$subdomain.$boxdomain的AAAA/A记录关联到对应的IP上
  /// 1. 外部系统需要自行确保subdomain不会冲突
  public var subdomain: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AllocVEIPReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ip: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_FreeVEIPRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ip: String = String()

  /// 释放VEIP时为了避免DNS cache的问题，会在删除对应DNS record后等待一定时间后再真实的释放对应VEIP
  /// 不指定则默认为10分钟
  public var waitSecond: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_FreeVEIPReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AppCertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appid: String = String()

  /// 单实例则为空，多实例为APP所部署时的UID
  public var uid: String = String()

  /// 证书有效时间，单位s
  public var validSeconds: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AppCertReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM格式的APP证书
  public var cert: String = String()

  /// PEM格式的APP私钥
  public var privateKey: String = String()

  /// 盒子证书，同一盒子内所有app的box_cert都是相同的，
  /// 可以作为CA证书的角色来使用
  public var boxCert: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AuthToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 登陆时服务器返回的token
  public var token: String = String()

  /// 若设置了此地址，则在未检测到auth-token时，
  /// 可以使用返回信息中的autologin_token_request_url进行自动查找auth-token
  /// 此地址一般时ingress等组件上提供的服务。
  /// 会通过html post form形式调用，附带token和redirect两个字段
  /// token为自动搜索到的token，redirect为AuthToken.autologin_redirect_url的值。
  /// 若token为空表示自动搜索token失败。
  public var autologinTokenPostURL: String = String()

  public var accessIp: String = String()

  public var autologinRedirectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_LoginInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var deviceID: String = String()

  public var when: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _when ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_when = newValue}
  }
  /// Returns true if `when` has been explicitly set.
  public var hasWhen: Bool {return self._when != nil}
  /// Clears the value of `when`. Subsequent reads from it will return its default value.
  public mutating func clearWhen() {self._when = nil}

  /// 若uid为空, ingress应该返回此html内容给浏览器进行自动登陆。
  /// 此html片段会尝试与hclient通讯获取auth-token后post到AuthToken.autologin_token_post_url上
  public var autologinTokenRequestContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _when: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Cloud_Lazycat_Apis_Sys_PeerID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_BoxInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 中心化服务器地址, 默认为origin.lazycat.cloud
  public var originServer: String = String()

  /// fc03:1136:38/40地址
  public var virtualIp: String = String()

  /// p2p节点id
  public var boxID: String = String()

  /// 注册到origin-server内的名称
  public var boxName: String = String()

  /// 从origin-server获取到的域名
  public var boxDomain: String = String()

  /// 证书管理器已经就续
  public var certReady: Bool = false

  /// PEM格式的盒子证书, 作为盒子系统其他app cert的CA证书。
  public var boxCert: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_DomainCertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var domain: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_DomainCertReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cert: String = String()

  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: String = String()

  public var isOnline: Bool = false

  /// 因为device api的监听端口可能会变化，所以此url有效性不会太长
  public var deviceApiURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ListDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ListDeviceReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var devices: [Cloud_Lazycat_Apis_Sys_Device] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_UserID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ChangeRoleReqeust {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var role: Cloud_Lazycat_Apis_Sys_Role = .normal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_QueryRoleReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var role: Cloud_Lazycat_Apis_Sys_Role = .normal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ResetPasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var oldPassword: String = String()

  public var newPassword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_DeleteUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_CreateUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var password: String = String()

  public var role: Cloud_Lazycat_Apis_Sys_Role = .normal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_ForceResetPasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var newPassword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Lazycat_Apis_Sys_Role: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_GenUserInvitationRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_UserInvitation: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ListUsersReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_PairDevicesRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AllocVEIPRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AllocVEIPReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_FreeVEIPRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_FreeVEIPReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AppCertRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AppCertReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AuthToken: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_LoginInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_PeerID: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_BoxInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_DomainCertRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_DomainCertReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_Device: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ListDeviceRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ListDeviceReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_UserID: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ChangeRoleReqeust: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_QueryRoleReply: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ResetPasswordRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_DeleteUserRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_CreateUserRequest: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_ForceResetPasswordRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.lazycat.apis.sys"

extension Cloud_Lazycat_Apis_Sys_Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ADMIN"),
  ]
}

extension Cloud_Lazycat_Apis_Sys_GenUserInvitationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenUserInvitationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_uid"),
    2: .standard(proto: "not_after"),
    3: .standard(proto: "limit_usage_count"),
    4: .standard(proto: "limit_role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._limitUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._notAfter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._limitUsageCount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._limitRole) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._limitUid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._notAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._limitUsageCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._limitRole {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_GenUserInvitationRequest, rhs: Cloud_Lazycat_Apis_Sys_GenUserInvitationRequest) -> Bool {
    if lhs._limitUid != rhs._limitUid {return false}
    if lhs._notAfter != rhs._notAfter {return false}
    if lhs._limitUsageCount != rhs._limitUsageCount {return false}
    if lhs._limitRole != rhs._limitRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_UserInvitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInvitation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_UserInvitation, rhs: Cloud_Lazycat_Apis_Sys_UserInvitation) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ListUsersReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUsersReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.uids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ListUsersReply, rhs: Cloud_Lazycat_Apis_Sys_ListUsersReply) -> Bool {
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_PairDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairDevicesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_id"),
    2: .standard(proto: "other_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.otherIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcID, fieldNumber: 1)
    }
    if !self.otherIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.otherIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_PairDevicesRequest, rhs: Cloud_Lazycat_Apis_Sys_PairDevicesRequest) -> Bool {
    if lhs.srcID != rhs.srcID {return false}
    if lhs.otherIds != rhs.otherIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AllocVEIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocVEIPRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "usage"),
    2: .same(proto: "subdomain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.usage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subdomain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.usage.isEmpty {
      try visitor.visitSingularStringField(value: self.usage, fieldNumber: 1)
    }
    if !self.subdomain.isEmpty {
      try visitor.visitSingularStringField(value: self.subdomain, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AllocVEIPRequest, rhs: Cloud_Lazycat_Apis_Sys_AllocVEIPRequest) -> Bool {
    if lhs.usage != rhs.usage {return false}
    if lhs.subdomain != rhs.subdomain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AllocVEIPReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocVEIPReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AllocVEIPReply, rhs: Cloud_Lazycat_Apis_Sys_AllocVEIPReply) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_FreeVEIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FreeVEIPRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .standard(proto: "wait_second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.waitSecond) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.waitSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.waitSecond, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_FreeVEIPRequest, rhs: Cloud_Lazycat_Apis_Sys_FreeVEIPRequest) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.waitSecond != rhs.waitSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_FreeVEIPReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FreeVEIPReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_FreeVEIPReply, rhs: Cloud_Lazycat_Apis_Sys_FreeVEIPReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AppCertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppCertRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .same(proto: "uid"),
    3: .standard(proto: "valid_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.validSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appid.isEmpty {
      try visitor.visitSingularStringField(value: self.appid, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if self.validSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.validSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AppCertRequest, rhs: Cloud_Lazycat_Apis_Sys_AppCertRequest) -> Bool {
    if lhs.appid != rhs.appid {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.validSeconds != rhs.validSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AppCertReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppCertReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cert"),
    2: .standard(proto: "private_key"),
    3: .standard(proto: "box_cert"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cert) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.boxCert) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularStringField(value: self.cert, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 2)
    }
    if !self.boxCert.isEmpty {
      try visitor.visitSingularStringField(value: self.boxCert, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AppCertReply, rhs: Cloud_Lazycat_Apis_Sys_AppCertReply) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.boxCert != rhs.boxCert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "autologin_token_post_url"),
    3: .standard(proto: "access_ip"),
    4: .standard(proto: "autologin_redirect_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.autologinTokenPostURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessIp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.autologinRedirectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.autologinTokenPostURL.isEmpty {
      try visitor.visitSingularStringField(value: self.autologinTokenPostURL, fieldNumber: 2)
    }
    if !self.accessIp.isEmpty {
      try visitor.visitSingularStringField(value: self.accessIp, fieldNumber: 3)
    }
    if !self.autologinRedirectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.autologinRedirectURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AuthToken, rhs: Cloud_Lazycat_Apis_Sys_AuthToken) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.autologinTokenPostURL != rhs.autologinTokenPostURL {return false}
    if lhs.accessIp != rhs.accessIp {return false}
    if lhs.autologinRedirectURL != rhs.autologinRedirectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_LoginInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "device_id"),
    3: .same(proto: "when"),
    4: .standard(proto: "autologin_token_request_content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._when) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.autologinTokenRequestContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try { if let v = self._when {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.autologinTokenRequestContent.isEmpty {
      try visitor.visitSingularStringField(value: self.autologinTokenRequestContent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_LoginInfo, rhs: Cloud_Lazycat_Apis_Sys_LoginInfo) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._when != rhs._when {return false}
    if lhs.autologinTokenRequestContent != rhs.autologinTokenRequestContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_PeerID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_PeerID, rhs: Cloud_Lazycat_Apis_Sys_PeerID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_BoxInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoxInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "origin_server"),
    2: .standard(proto: "virtual_ip"),
    3: .standard(proto: "box_id"),
    4: .standard(proto: "box_name"),
    5: .standard(proto: "box_domain"),
    6: .standard(proto: "cert_ready"),
    7: .standard(proto: "box_cert"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originServer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.virtualIp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.boxID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.boxName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.boxDomain) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.certReady) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.boxCert) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.originServer.isEmpty {
      try visitor.visitSingularStringField(value: self.originServer, fieldNumber: 1)
    }
    if !self.virtualIp.isEmpty {
      try visitor.visitSingularStringField(value: self.virtualIp, fieldNumber: 2)
    }
    if !self.boxID.isEmpty {
      try visitor.visitSingularStringField(value: self.boxID, fieldNumber: 3)
    }
    if !self.boxName.isEmpty {
      try visitor.visitSingularStringField(value: self.boxName, fieldNumber: 4)
    }
    if !self.boxDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.boxDomain, fieldNumber: 5)
    }
    if self.certReady != false {
      try visitor.visitSingularBoolField(value: self.certReady, fieldNumber: 6)
    }
    if !self.boxCert.isEmpty {
      try visitor.visitSingularStringField(value: self.boxCert, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_BoxInfo, rhs: Cloud_Lazycat_Apis_Sys_BoxInfo) -> Bool {
    if lhs.originServer != rhs.originServer {return false}
    if lhs.virtualIp != rhs.virtualIp {return false}
    if lhs.boxID != rhs.boxID {return false}
    if lhs.boxName != rhs.boxName {return false}
    if lhs.boxDomain != rhs.boxDomain {return false}
    if lhs.certReady != rhs.certReady {return false}
    if lhs.boxCert != rhs.boxCert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_DomainCertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DomainCertRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_DomainCertRequest, rhs: Cloud_Lazycat_Apis_Sys_DomainCertRequest) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_DomainCertReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DomainCertReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cert"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cert) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularStringField(value: self.cert, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_DomainCertReply, rhs: Cloud_Lazycat_Apis_Sys_DomainCertReply) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "is_online"),
    3: .standard(proto: "device_api_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isOnline) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceApiURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 1)
    }
    if self.isOnline != false {
      try visitor.visitSingularBoolField(value: self.isOnline, fieldNumber: 2)
    }
    if !self.deviceApiURL.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceApiURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_Device, rhs: Cloud_Lazycat_Apis_Sys_Device) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.isOnline != rhs.isOnline {return false}
    if lhs.deviceApiURL != rhs.deviceApiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ListDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ListDeviceRequest, rhs: Cloud_Lazycat_Apis_Sys_ListDeviceRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ListDeviceReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ListDeviceReply, rhs: Cloud_Lazycat_Apis_Sys_ListDeviceReply) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_UserID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_UserID, rhs: Cloud_Lazycat_Apis_Sys_UserID) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ChangeRoleReqeust: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChangeRoleReqeust"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.role != .normal {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ChangeRoleReqeust, rhs: Cloud_Lazycat_Apis_Sys_ChangeRoleReqeust) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_QueryRoleReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRoleReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.role != .normal {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_QueryRoleReply, rhs: Cloud_Lazycat_Apis_Sys_QueryRoleReply) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ResetPasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "old_password"),
    3: .standard(proto: "new_password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 2)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ResetPasswordRequest, rhs: Cloud_Lazycat_Apis_Sys_ResetPasswordRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_DeleteUserRequest, rhs: Cloud_Lazycat_Apis_Sys_DeleteUserRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_CreateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "password"),
    3: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.role != .normal {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_CreateUserRequest, rhs: Cloud_Lazycat_Apis_Sys_CreateUserRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.password != rhs.password {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_ForceResetPasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForceResetPasswordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "new_password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_ForceResetPasswordRequest, rhs: Cloud_Lazycat_Apis_Sys_ForceResetPasswordRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
