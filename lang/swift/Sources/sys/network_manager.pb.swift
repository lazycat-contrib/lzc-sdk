// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sys/network_manager.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 不可用
  case unavailable // = 0

  /// 未连接
  case disconnected // = 1

  /// 正在连接
  case connecting // = 2

  /// 已连接
  case connected // = 3

  /// 正在断开
  case disconnecting // = 4

  /// 已禁用
  case disabled // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unavailable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unavailable
    case 1: self = .disconnected
    case 2: self = .connecting
    case 3: self = .connected
    case 4: self = .disconnecting
    case 5: self = .disabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unavailable: return 0
    case .disconnected: return 1
    case .connecting: return 2
    case .connected: return 3
    case .disconnecting: return 4
    case .disabled: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus] = [
    .unavailable,
    .disconnected,
    .connecting,
    .connected,
    .disconnecting,
    .disabled,
  ]
}

#endif  // swift(>=4.2)

public enum Cloud_Lazycat_Apis_Sys_KeyMgmt: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// WEP  （最老的协议了，目前几乎没人用）
  case wep // = 1

  /// WPA/WPA2-Personal  （一般大概率都是这个，应当作为默认值）
  case wpaPsk // = 2

  /// WPA3-Personal  （新一代协议，用的人比较少）
  case sae // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .wep
    case 2: self = .wpaPsk
    case 3: self = .sae
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .wep: return 1
    case .wpaPsk: return 2
    case .sae: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Sys_KeyMgmt: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Sys_KeyMgmt] = [
    .none,
    .wep,
    .wpaPsk,
    .sae,
  ]
}

#endif  // swift(>=4.2)

public enum Cloud_Lazycat_Apis_Sys_WifiConnectResult: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case success // = 0
  case noSuchBssid // = 1
  case wrongPassword // = 2
  case unknownError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .noSuchBssid
    case 2: self = .wrongPassword
    case 3: self = .unknownError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .noSuchBssid: return 1
    case .wrongPassword: return 2
    case .unknownError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cloud_Lazycat_Apis_Sys_WifiConnectResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cloud_Lazycat_Apis_Sys_WifiConnectResult] = [
    .success,
    .noSuchBssid,
    .wrongPassword,
    .unknownError,
  ]
}

#endif  // swift(>=4.2)

public struct Cloud_Lazycat_Apis_Sys_AccessPointInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 热点的网卡 mac 地址（由于 ssid 可能重复，所以将此字段作为整个列表的 index）
  public var bssid: String = String()

  /// 热点的 ssid
  public var ssid: String = String()

  /// 信号强度（范围 0 <= signal <= 100）
  public var signal: Int32 = 0

  /// 是否需要密码
  public var security: Bool = false

  /// 是否已连接
  public var connected: Bool = false

  /// 是否已保存密码
  public var saved: Bool = false

  /// 是否自动连接
  public var autoConnected: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_AccessPointInfoList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [Cloud_Lazycat_Apis_Sys_AccessPointInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_NetworkDeviceStatusInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已连接到互联网
  public var hasInternet_p: Bool = false

  /// 有线连接状态（已假设只有一块有线网卡）
  public var wiredDevice: Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus = .unavailable

  /// 无线设备状态（已假设只有一块无线网卡）
  public var wirelessDevice: Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus = .unavailable

  /// 若无线设备已连接，则该字段表示已连接的 wifi 的信息
  public var info: Cloud_Lazycat_Apis_Sys_AccessPointInfo {
    get {return _info ?? Cloud_Lazycat_Apis_Sys_AccessPointInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Cloud_Lazycat_Apis_Sys_AccessPointInfo? = nil
}

public struct Cloud_Lazycat_Apis_Sys_WifiConnectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bssid 和 ssid 指定其一即可
  public var bssid: String = String()

  public var ssid: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_WifiConfigInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ssid: String = String()

  public var password: String = String()

  public var keyMgmt: Cloud_Lazycat_Apis_Sys_KeyMgmt = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Lazycat_Apis_Sys_WifiConnectReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Cloud_Lazycat_Apis_Sys_WifiConnectResult = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_KeyMgmt: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_WifiConnectResult: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AccessPointInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_AccessPointInfoList: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_NetworkDeviceStatusInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_WifiConnectInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_WifiConfigInfo: @unchecked Sendable {}
extension Cloud_Lazycat_Apis_Sys_WifiConnectReply: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.lazycat.apis.sys"

extension Cloud_Lazycat_Apis_Sys_NetworkDeviceStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NetworkDeviceStatusUnavailable"),
    1: .same(proto: "NetworkDeviceStatusDisconnected"),
    2: .same(proto: "NetworkDeviceStatusConnecting"),
    3: .same(proto: "NetworkDeviceStatusConnected"),
    4: .same(proto: "NetworkDeviceStatusDisconnecting"),
    5: .same(proto: "NetworkDeviceStatusDisabled"),
  ]
}

extension Cloud_Lazycat_Apis_Sys_KeyMgmt: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KeyMgmtNone"),
    1: .same(proto: "KeyMgmtWEP"),
    2: .same(proto: "KeyMgmtWPA_PSK"),
    3: .same(proto: "KeyMgmtSAE"),
  ]
}

extension Cloud_Lazycat_Apis_Sys_WifiConnectResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WifiConnectResultSuccess"),
    1: .same(proto: "WifiConnectResultNoSuchBssid"),
    2: .same(proto: "WifiConnectResultWrongPassword"),
    3: .same(proto: "WifiConnectResultUnknownError"),
  ]
}

extension Cloud_Lazycat_Apis_Sys_AccessPointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessPointInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bssid"),
    2: .same(proto: "ssid"),
    3: .same(proto: "signal"),
    4: .same(proto: "security"),
    5: .same(proto: "connected"),
    6: .same(proto: "saved"),
    7: .standard(proto: "auto_connected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.signal) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.security) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.saved) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.autoConnected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bssid.isEmpty {
      try visitor.visitSingularStringField(value: self.bssid, fieldNumber: 1)
    }
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 2)
    }
    if self.signal != 0 {
      try visitor.visitSingularInt32Field(value: self.signal, fieldNumber: 3)
    }
    if self.security != false {
      try visitor.visitSingularBoolField(value: self.security, fieldNumber: 4)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 5)
    }
    if self.saved != false {
      try visitor.visitSingularBoolField(value: self.saved, fieldNumber: 6)
    }
    if self.autoConnected != false {
      try visitor.visitSingularBoolField(value: self.autoConnected, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AccessPointInfo, rhs: Cloud_Lazycat_Apis_Sys_AccessPointInfo) -> Bool {
    if lhs.bssid != rhs.bssid {return false}
    if lhs.ssid != rhs.ssid {return false}
    if lhs.signal != rhs.signal {return false}
    if lhs.security != rhs.security {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.saved != rhs.saved {return false}
    if lhs.autoConnected != rhs.autoConnected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_AccessPointInfoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessPointInfoList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_AccessPointInfoList, rhs: Cloud_Lazycat_Apis_Sys_AccessPointInfoList) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_NetworkDeviceStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkDeviceStatusInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasInternet"),
    2: .same(proto: "WiredDevice"),
    3: .same(proto: "WirelessDevice"),
    4: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasInternet_p) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.wiredDevice) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.wirelessDevice) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.hasInternet_p != false {
      try visitor.visitSingularBoolField(value: self.hasInternet_p, fieldNumber: 1)
    }
    if self.wiredDevice != .unavailable {
      try visitor.visitSingularEnumField(value: self.wiredDevice, fieldNumber: 2)
    }
    if self.wirelessDevice != .unavailable {
      try visitor.visitSingularEnumField(value: self.wirelessDevice, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_NetworkDeviceStatusInfo, rhs: Cloud_Lazycat_Apis_Sys_NetworkDeviceStatusInfo) -> Bool {
    if lhs.hasInternet_p != rhs.hasInternet_p {return false}
    if lhs.wiredDevice != rhs.wiredDevice {return false}
    if lhs.wirelessDevice != rhs.wirelessDevice {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_WifiConnectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WifiConnectInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bssid"),
    2: .same(proto: "ssid"),
    3: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bssid.isEmpty {
      try visitor.visitSingularStringField(value: self.bssid, fieldNumber: 1)
    }
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_WifiConnectInfo, rhs: Cloud_Lazycat_Apis_Sys_WifiConnectInfo) -> Bool {
    if lhs.bssid != rhs.bssid {return false}
    if lhs.ssid != rhs.ssid {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_WifiConfigInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WifiConfigInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "password"),
    3: .standard(proto: "key_mgmt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyMgmt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.keyMgmt != .none {
      try visitor.visitSingularEnumField(value: self.keyMgmt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_WifiConfigInfo, rhs: Cloud_Lazycat_Apis_Sys_WifiConfigInfo) -> Bool {
    if lhs.ssid != rhs.ssid {return false}
    if lhs.password != rhs.password {return false}
    if lhs.keyMgmt != rhs.keyMgmt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Lazycat_Apis_Sys_WifiConnectReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WifiConnectReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Lazycat_Apis_Sys_WifiConnectReply, rhs: Cloud_Lazycat_Apis_Sys_WifiConnectReply) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
