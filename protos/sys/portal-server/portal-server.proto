syntax = "proto3";

package cloud.lazycat.apis.sys;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

option go_package = "gitee.com/linakesi/lzc-sdk/lang/go/sys/portal-server";

service HPortalSys {
  // 用auth-token反向查询登陆的设备以及UID
  rpc QueryLogin(AuthToken) returns (LoginInfo) {}

  rpc QueryBoxInfo(google.protobuf.Empty) returns (BoxInfo) {}

  // 获取盒子所属域名下或下一级域名的https证书。
  // 注意不是所有ACME服务器都支持泛域名。
  rpc GetDomainCert(DomainCertRequest) returns (DomainCertReply) {}

  // 申请额外的外部可访问的IP,并配置对应访问域名
  rpc AllocVirtualExternalIP(AllocVEIPRequest) returns (AllocVEIPReply) {}
  // 释放虚拟IP
  rpc FreeVirtualExternalIP(FreeVEIPRequest)  returns (FreeVEIPReply) {}

  //  查询所有UID
  rpc ListUsers(google.protobuf.Empty) returns (ListUsersReply) {}
  //  创建用户信息
  rpc CreateUser(CreateUserRequest) returns (google.protobuf.Empty){}
  //  删除用户信息
  rpc DeleteUser(DeleteUserRequest) returns (google.protobuf.Empty){}
  //  修改新的密码
  rpc ResetPassword(ResetPasswordRequest) returns(google.protobuf.Empty){}
  //  校验用户密码是否正确
  rpc CheckPassword(CheckPasswordRequest) returns (google.protobuf.Empty) {}
  //  根据用户uid查询用户信息
  rpc QueryRole(UserID) returns (QueryRoleReply) {}
  //  修改指定uid的用户角色
  rpc ChangeRole(ChangeRoleReqeust) returns(google.protobuf.Empty){}
  //  添加或删除受信任设备
  rpc ChangeTrustEndDevice(ChangeTrustEndDeviceRequest) returns (ChangeTrustEndDeviceReply) {}
  // 根据UID返回所有的设备列表
  rpc ListDevices(ListDeviceRequest) returns (ListDeviceReply) {}
  rpc QueryDeviceByID(DeviceID) returns (Device) {}

  // 删除登陆的会话状态
  rpc ClearLoginSession(ClearLoginSessionRequest) returns (ClearLoginSessionReply) {}

  // 获取remotesocks服务器地址
  rpc RemoteSocks(RemoteSocksRequest) returns (RemoteSocksReply) {}

  // hserver重启后默认设置BoxSystem为booting状态
  // 实际的BoxSystem需要定期(建议两到三秒)设置其实际状态，避免hserver被手动或自动重启后设置的盒子系统状态错误
  rpc UpdateBoxSystemStatus(UpdateBoxSystemStatusRequest) returns (UpdateBoxSystemStatusResponse) {}

  // ----------------------------- 以下为准备废弃的接口 --------------------------------------

  rpc GetDomainSelfCert(DomainCertRequest) returns (DomainCertReply) {option deprecated=true;}
  rpc UpdateBoxStatus(UpdateBoxStatusRequest) returns (UpdateBoxStatusResponse) {option deprecated=true;}
  rpc ForceResetPassword(ForceResetPasswordRequest) returns (google.protobuf.Empty){option deprecated=true;}

  // 强制注销当前用户指定设备.
  // 1. 删除设备应该通过ChangeTrustEndDevice来处理
  // 2. 强制断开会话应该由ClearSession接口完成
  rpc Logout(LogoutRequest)returns(google.protobuf.Empty) {option deprecated=true;}

  // 以下接口要改名字
  // 强制将特定设备加到受信任列表中
  rpc TrustUserDevice(TrustUserDeviceRequest) returns (google.protobuf.Empty) {option deprecated=true;}


  // hportal不应该处理app cert相关逻辑，上层逻辑应该通过GetDomainCert获取到crt和key后自行处理
  // 在部署具体app前，调用此接口获取app证书
  // APP证书格式为:
  //   Issuer: O = $BOX.ORIGIN, CN = $BOX.DOMAIN, serialNumber = $BOX.ID
  //   Subject: O = $BOX.ORIGIN, CN = $APP.DOMAIN, serialNumber = '$UID@$APP.ID || $APP.ID'
  // Issuer为box.crt，通过QueryBoxInfo查询到BoxInfo.BoxCrt。并且box.crt的公钥与box.id是一一对应关系。
  //
  // 盒子内部组件可以直接通过QueryBoxInfo来验证信任链是否合法，盒子外部系统需要通过其他机制比如libp2p.identify去验证box.crt的合法性。
  //
  rpc GetAppCert(AppCertRequest) returns (AppCertReply) {option deprecated=true;}
}

message RemoteSocksRequest {
  enum LocationType {
    Unkonwn = 0;

    //在当前hserver所处的物理网络协议栈上提供socks服务
    Local = 1;

    //在指定的的hclient所处的物理网络协议栈上提供socks服务
    Remote = 2;
  }

  LocationType location_type = 1;

  string target = 2; //若Type为Remote则，填写节点的peer.ID
}

message RemoteSocksReply {
  string server_url = 1; //返回的socks5服务器地址
}

message ListUsersReply {
  repeated string uids = 1;
}

message AllocVEIPRequest {
  // 简短说明使用原因，方便后续管理
  string usage = 1;

  // 关联的子域名。hserver会自动将$subdomain.$boxdomain的AAAA/A记录关联到对应的IP上
  // 1. 外部系统需要自行确保subdomain不会冲突
  string subdomain = 2;
}
message AllocVEIPReply {
  string ip = 1;
}

message FreeVEIPRequest {
  string ip = 1;

  // 释放VEIP时为了避免DNS cache的问题，会在删除对应DNS record后等待一定时间后再真实的释放对应VEIP
  // 不指定则默认为10分钟
  int32 wait_second = 2;
}
message FreeVEIPReply {}

message AuthToken {
  // 登陆时服务器返回的token
  string token = 1;

  // 若token_type = HTTPBasicAuth
  // 则必须包含此字段，以便hportal可以分析出正确的登陆设备
  // 若仅仅是为了验证帐号密码是否正确，直接调用CheckPassword接口
  string access_ip = 3;

  enum TokenType {
    Raw = 0;       // token return by hportal-server login method
    HTTPBasicAuth = 1; // QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  }
  TokenType token_type = 5;


  // 若设置了此地址，则在未检测到auth-token时，
  // 可以使用返回信息中的autologin_token_request_url进行自动查找auth-token
  // 此地址一般是ingress等组件上提供的服务。
  // 会通过html post form形式调用，附带token和redirect两个字段
  // token为自动搜索到的token，redirect为AuthToken.autologin_redirect_url的值。
  // 若token为空表示自动搜索token失败。
  string autologin_token_post_url = 2 [deprecated=true];
  string autologin_redirect_url = 4 [deprecated=true];
}

message LoginInfo {
  string uid = 1;

  string device_id = 2;

  // 最近登陆时间，因为针对弱网优化因此不一定等于本次登陆时间
  // 只有hserver重启或调用了ClearLoginSession后，才会真属于退出状态
  google.protobuf.Timestamp when = 3;

  // 若uid为空, ingress应该返回此html内容给浏览器进行自动登陆。
  // 此html片段会尝试与hclient通讯获取auth-token后post到AuthToken.autologin_token_post_url上
  string autologin_token_request_content = 4 [deprecated=true];

  // 当前登陆设备的版本信息
  string device_version = 5;

  // 登陆时服务器返回的token
  string token = 6;
}


message DeviceID {
  string id = 1;
}

message BoxInfo {
  // 中心化服务器地址, 默认为origin.lazycat.cloud
  string origin_server = 1;

  // fc03:1136:38/40地址
  string virtual_ip = 2;

  // p2p节点id
  string box_id = 3;

  // 注册到origin-server内的名称
  string box_name = 4;

  // 从origin-server获取到的域名
  string box_domain = 5;

  // 证书管理器已经就续
  bool cert_ready = 6;

  // PEM格式的盒子证书, 作为盒子系统其他app cert的CA证书。
  string box_cert = 7;
}

message DomainCertRequest {
  string domain = 1;
}
message DomainCertReply {
  string cert = 1;
  string key = 2;

  bytes ocsp = 3;
}


message Device {
  // 设备的唯一ID
  string udid = 7;

  // 此设备当前是否连接到盒子
  bool is_online = 2;

  // 因为device api的监听端口可能会变化，所以此url有效性不会太长
  string device_api_url = 3;

  // 设备名称
  string name = 4;

  // 设备型号
  string model = 5;

  // 设备绑定时间
  google.protobuf.Timestamp binding_time = 6;


  // TODO 待删除, 上层不应该感知peer_id
  string peer_id = 1 [deprecated=true];

  // 设备是否是移动平台
  // 此字段应该由上层代码自行分析
  bool is_mobile = 8 [deprecated=true];
}

message ListDeviceRequest {
  string uid = 1;
}

message ListDeviceReply {
  repeated Device devices = 1;
}

message UserID {
  string uid = 1;
}

enum Role {
  NORMAL = 0;
  ADMIN = 1;
}

message ChangeRoleReqeust{
  string uid = 1;
  Role role = 2;
}

message QueryRoleReply {
  string uid = 1;
  Role role = 2;
}


message ResetPasswordRequest{
  string uid = 1;
  reserved 2;
  string new_password = 3;
}

message DeleteUserRequest {
  string uid = 1;
}

message CreateUserRequest{
  string uid = 1;
  string password = 2;
  Role role = 3;
}


message CheckPasswordRequest{
  string uid = 1;
  string password = 2;
}

message ClearLoginSessionRequest {
  // 对此UID下的所有设备进行处理
  string uid = 1;

  // 但不对以下设备进行操作
  repeated string exclude_devices = 2;
}
message ClearLoginSessionReply {}

message ChangeTrustEndDeviceRequest{
  string uid = 1;

  string cid = 2; //如果是Add,则此字段内容应该为合法的PeerID，若为Del则应该是device_id

  enum Action {
    Add = 0;
    Del = 1;
  }
  Action action = 3;
}
message ChangeTrustEndDeviceReply{}


// 此message的字段需要和hportal/apis/boxapi/common.proto中的BoxSystemStatus保持同步
message UpdateBoxSystemStatusRequest {
  enum SysStatus {
    // 系统正在启动中
    Booting = 0;

    // 处于正常可用状态
    // 一般此状态下service_url应该设置为https://$boxdomain
    // proxy_the_service_url和only_admin_can_access_service_url都设置为false
    Normal = 1;

    // 处于异常状态，具体原因可读取ExceptionReason
    // 一般此状态下service_url需要特殊设置且
    // proxy_the_service_url和only_admin_can_access_service_url都设置为true
    Exception = 2;
  }

  enum ExceptionReason {
    // 其他原因
    Unknown = 0;

    // 等待加密数据盘被解密
    WaitDataDiskDecryption = 1;

    // 磁盘未初始化
    DataDiskNotInit = 2;
  }

  SysStatus status = 1;

  string service_url = 2;

  optional ExceptionReason exception_reason = 3;

  // 若为true, 在hclient侧生成一个临时的[fc03:1136:3800::1]:$x地址提供给客户端访问.
  // 具体会体现在shellapi.proto:BoxInfo.BoxHomeUrl上
  bool proxy_the_service_url = 4;

  // 在proxy_the_service_url=true时，支持设置是否仅管理员用户可以访问service_url
  // 此处的权限管控仅是网络传输层面,service_url本身需要做基本的网络隔离，比如使用unix socket协议
  bool only_admin_can_access_service_url = 5;
}

message UpdateBoxSystemStatusResponse{}


// 以下接口废弃-------------------------
message UpdateBoxStatusRequest{
  option deprecated = true;
  // 盒子是否启动完毕
  optional bool start_up = 1;
  // 盒子数据盘状态是否OK
  optional bool data_partition = 2;
}
message UpdateBoxStatusResponse{
  option deprecated = true;
}
message TrustUserDeviceRequest{
  option deprecated = true;

  string udid = 1;
  string user = 2;
}
message ForceResetPasswordRequest{
  option deprecated = true;

  string uid = 1;
  string new_password = 2;
}
message LogoutRequest{
  option deprecated = true;

  string uid = 1;

  // 设备唯一id
  string udid = 2; //若为空，表示uid下的所有设备

  // 注销原因
  Reason reason = 3;

  enum Reason {
    LogoutAndDeleteEndDevice = 0; //从受信任列表中，删除udid对应的设备

    LogoutByUser = 1; //仅强制注销udid对应的设备
  }
}

message AppCertRequest {
  string appid = 1;

  // 单实例则为空，多实例为APP所部署时的UID
  string uid = 2;

  // 证书有效时间，单位s
  int32 valid_seconds = 3;
}

message AppCertReply {
  // PEM格式的APP证书
  string cert = 1;

  // PEM格式的APP私钥
  string private_key = 2;

  // 盒子证书，同一盒子内所有app的box_cert都是相同的，
  // 可以作为CA证书的角色来使用
  string box_cert = 3;
}
