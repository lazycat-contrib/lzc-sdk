package main

import (
	"fmt"
	"sort"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	P "gitee.com/linakesi/lzc-sdk/lang/go/common"
)

type Rule struct {
	mn    string
	perms []P.Permission
}

func perms2ints(ps []P.Permission) string {
	ret := "[]int{"
	for i, p := range ps {
		ret += strconv.Itoa(int(p))
		if i != 0 {
			ret += ","
		}
	}
	return ret + "}"
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		var rules []Rule
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			rules = ExtractScontext(rules, f)
		}
		sort.Slice(rules, func(i, j int) bool {
			return rules[i].mn < rules[j].mn
		})

		g := gen.NewGeneratedFile("scontext.rules.go", "")
		g.P("// Code generated by protoc-gen-lzc. DO NOT EDIT.")
		g.P()
		g.P("package scontext")
		g.P("func ListPermission(methodName string) []int {")
		g.P("switch (methodName) {")
		for _, r := range rules {
			if len(r.perms) == 0 {
				continue
			}
			fmt.Fprintf(g, "case %q: \n//%v\nreturn %s;", r.mn, r.perms, perms2ints(r.perms))
		}
		g.P("}")
		g.P("return nil")
		g.P("}")
		g.P()

		return nil
	})
}

func ExtractScontext(rules []Rule, file *protogen.File) []Rule {
	for _, s := range file.Services {
		for _, m := range s.Methods {
			o := m.Desc.Options()
			if o == nil {
				continue
			}

			if !proto.HasExtension(o, P.E_Scontext) {
				continue
			}
			ext := proto.GetExtension(o, P.E_Scontext).(*P.SecurityContextRequire)

			rules = append(rules, Rule{
				mn:    string(m.Desc.FullName()),
				perms: ext.RequirePermissions,
			})
		}
	}
	return rules
}
