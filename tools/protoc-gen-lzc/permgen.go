package main

import (
	"fmt"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	P "gitee.com/linakesi/lzc-apis-protos/lang/go/common"
)

func perms2ints(ps []P.Permission) string {
	ret := "[]int{"
	for i, p := range ps {
		ret += strconv.Itoa(int(p))
		if i != 0 {
			ret += ","
		}
	}
	return ret + "}"
}

func main() {
	rules := make(map[string][]P.Permission)

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			ExtractScontext(f, rules)
		}

		g := gen.NewGeneratedFile("scontext.rules.go", "")
		g.P("// Code generated by protoc-gen-lzc. DO NOT EDIT.")
		g.P()
		g.P("package scontext")
		g.P("func ListPermission(methodName string) []int {")
		g.P("switch (methodName) {")
		for mn, perms := range rules {
			fmt.Fprintf(g, "case %q: \n//%v\nreturn %s;", mn, perms, perms2ints(perms))
		}
		g.P("}")
		g.P("}")
		g.P()

		return nil
	})
}

func ExtractScontext(file *protogen.File, rules map[string][]P.Permission) {
	for _, s := range file.Services {
		for _, m := range s.Methods {
			o := m.Desc.Options()
			if o == nil {
				continue
			}

			if !proto.HasExtension(o, P.E_Scontext) {
				continue
			}
			ext := proto.GetExtension(o, P.E_Scontext).(*P.SecurityContext)

			rules[fmt.Sprintf("%s", m.Desc.FullName())] = ext.RequirePermissions
		}
	}
}
